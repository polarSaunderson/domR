% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/timers.R
\name{end_timer}
\alias{end_timer}
\title{Ends the timer}
\usage{
end_timer(startTime, ..., sound = TRUE)
}
\arguments{
\item{startTime}{Use the output from \code{\link[=start_timer]{start_timer()}} as input here}

\item{...}{"string": Name of the process that has been timed; all arguments
will be displayed in the order entered using \code{\link[=cat3]{cat3()}}.}

\item{sound}{BINARY: Should a sound be played upon completion? Requires
\code{beepr}.}
}
\description{
This function and \code{\link[=start_timer]{start_timer()}} are mainly because I can
never remember the syntax/name of \code{\link[=proc.time]{proc.time()}}. Simply call
\code{\link[=start_timer]{start_timer()}} before the process you are timing begins, and then call
\code{\link[=end_timer]{end_timer()}} afterwards, feeding it with the output of \code{\link[=start_timer]{start_timer()}}.
This function invisibly returns the time of it finishing, so it can be
used in a subsequent \code{\link[=end_timer]{end_timer()}} function call and the timing of
processes can be chained together. See the usage examples.
}
\examples{
\dontrun{
  start <- start_timer()
  Sys.sleep(0.2) # do code!
  end_timer(start)

  start2 <- start_timer()
  Sys.sleep(0.2) # do code!
  end_timer(start2, "code block 1", FALSE)
  Sys.sleep(0.8) # do more code!
  end_timer(start2, "code block 2")

  start3 <- start_timer()
  Sys.sleep(0.2) # do code!
  end1 <- end_timer(start3, "code block 1", FALSE)

  Sys.sleep(0.6) # do more code!
  end_timer(end1, "code block 2", FALSE)
  end_timer(start, "overall time")
}
}
